fluidRow(
box(title = tags$p(strong("Introduction", style = "font-size:22px")),
status = "primary",
solidHeader = TRUE,
collapsible = FALSE,
width = 12,
color = "light-blue",
fluidRow(
style = "font-size:19px;",
column(width = 2,
align = "left",
offset = 0,
style = "padding-right:0px",
img(src = "https://raw.githubusercontent.com/bbarker505/BOXB-webapp/main/images/boxb_infected_leaves_2.png", width = "100%", height = "50%")),
column(width = 10,
offset = 0,
p("The boxwood blight infection risk mapping tool uses gridded
climate data to calculate the risk of boxwood being infected
by boxwood blight in western Oregon and Washington. The disease,
caused by the fungus ", em("Calonectria pseudonaviculata "),
"can result in defoliation, decline, and death of susceptible
varieties. These include most varieties of ",
em("Buxus sempervirens"), " such as \u0022Suffruticosa\u0022
(English boxwood) and \u0022Justin Brouwers\u0022.",
"Climate data are derived from the ",
a(href = "https://www.prism.oregonstate.edu", "PRISM"),
"database at a 800 m",
tags$sup(2, .noWS = "before"), " resolution. Presently models
are run only for areas west of the Cascades
(approximately west of \u2013120.5 \u00B0W).
Please see a", a(href = "https://www.prism.oregonstate.edu", "tutorial"),
"for details on tool use and map interpretation."))))),
# Risk menu selections
fluidRow(
style = "font-size:19px;",
tabItems(
## Risk map selection
tabItem(
tabName = "risk_maps",
box(
title = tags$p(strong("Risk Map", style = "font-size:22px")),
width = 12,
status ="primary",
solidHeader = TRUE,
collapsible = FALSE,
column(
width = 3,
radioButtons("risk",
label = tags$span("Select risk map",
bsButton("info_maptype",
label = "",
icon = icon("info"),
style = "info",
size = "extra-small")),
choices = c("Three Day", "Four Day", "Cumulative (Total)"),
selected = "Three Day"),
# Popover info box
bsPopover(
id = "info_maptype",
title = "Information",
content = info_maptype,
placement = "right",
trigger = "hover",
options = list(container = "body"))),
## Address selection and entry
column(
width = 4,
checkboxInput("address_checkbox",
value = FALSE,
label = tags$span("Locate an address",
bsButton("info_address",
label = "",
icon = icon("info"),
style = "info",
size = "extra-small"))),
# Popover info box
bsPopover(
id = "info_address",
title = "Information",
content = info_address,
placement = "right",
trigger = "hover",
options = list(container = "body")),
# Conditional panel of address box is selected
conditionalPanel(
condition = "input.address_checkbox == 1",
textInput("address", "Enter an address, city, or place",
value = ""),
actionButton("address_submit", "Submit"))),
column(
width = 3,
checkboxInput("lastYr_checkbox",
value = FALSE,
label = tags$span("Compare to last year",
bsButton("info_lastYr",
label = "",
icon = icon("info"),
style = "info",
size = "extra-small"))),
bsPopover(
id = "info_lastYr",
title = "Information",
content = info_lastYr,
placement = "right",
trigger = "hover",
options = list(container = "body")),
)))),
# Error message
#uiOutput("address_error"),
fluidRow(style="padding-left:15px;margin-top:1em;font-size:19px;",
column(width = 12, uiOutput("address_error")),
column(width = 12, uiOutput("coords_error"))),
# Risk map titles row - will always have a row for current map,
# but title row for last year maps depends on user input
fluidRow(style = "font-size:19px;",
column(width = 6, align = "center",
div(style = "font-size:22px;font-weight:bold;
margin-top:0.5em;padding:5px;text-decoration:underline;",
paste("Today:", format(current_date, "%b-%d-%Y")))),
uiOutput("title_row_lastYr")), # Last year map title
# Risk map value for geocoded address
conditionalPanel(
condition = "input.address_checkbox == 1",
fluidRow(style = "font-size:19px;padding-left:15px;",
column(width = 6, uiOutput("coords_value_current")),
column(width = 6, uiOutput("coords_value_lastYr")))),
# Risk maps
fluidRow(style = "padding-left:15px;",
column(width = 12, uiOutput("risk_map"))),
# Acknowledgements - text
fluidRow(style="padding-left:15px;margin-top:1.5em;font-size:19px;",
box(title = tags$p(strong("Acknowledgements", style = "font-size:22px")),
status = "primary",
solidHeader = TRUE,
collapsible = FALSE,
width = 12,
color = "light-blue",
fluidRow(
style = "font-size:19px;",
column(width = 12,
p("Creation of this app was funded by an Oregon
Department of Agriculture Nursery Research Grant number ODA-4310-A."),
p("Work on the boxwood blight risk model was funded by
the US Farm Bill FY17 and sponsored by the USDA APHIS
PPQ agreement number 20-8130-0282-CA, and by National
Institute of Food and Agriculture Crop Protection and
Pest Management Extension Implementation Program grant
number 2021-70006-35581."),
p("Many collaborators from OSU, USDA ARS, Virginia Tech, and
North Carolina State University helped improve the model.")))))),
# Contact with errors
fluidRow(style="padding-left:0px;;margin-top:1.5em;font-size:19px;",
box(title = tags$p(strong("Find errors or have questions?", style = "font-size:22px")),
status = "primary",
solidHeader = TRUE,
collapsible = FALSE,
width = 12,
color = "light-blue",
fluidRow(
style = "font-size:19px;",
column(width = 12,
p("Please contact", a(href = "brittany.barker@oregonstate.edu", "Brittany Barker.")))))),
# Acknowledgements - logos
fluidRow(
column(width = 3, align = "center", offset = 0,
img(src = "https://raw.githubusercontent.com/bbarker505/BOXB-webapp/main/images/OIPMC.png", width = "65%")),
column(width = 3, align = "center", offset = 0,
img(src = "https://raw.githubusercontent.com/bbarker505/BOXB-webapp/main/images/Oregon-Department-of-Agriculture-logo.png", width = "65%")),
column(width = 3, align = "center", offset = 0,
img(src = "https://raw.githubusercontent.com/bbarker505/BOXB-webapp/main/images/PRISM.png", width = "55%")),
column(width = 3, align = "center", offset = 0,
img(src = "https://raw.githubusercontent.com/bbarker505/BOXB-webapp/main/images/usda-logo_original.png", width = "35%"))))))
# Server ----
server <- function(input, output) {
# Resize map widths based on whether map for last year is selected
# 100%: maps (both years) span entire column width (=12)
# 50%: current map only spans half the column width (=6)
# Expression used in leaflet maps below
map_width <- reactive({
if (input$lastYr_checkbox == 1) {
"100%"
} else {
"50%"
}
})
#### * Map title(s) ####
# If maps for last year are selected, then there will be two titles
# Important: column width for each map must be 6 to match dimensions of maps
title_row_lastYr <- eventReactive(input$lastYr_checkbox, {
column(width = 6, align = "center",
div(style = "font-size:22px;font-weight:bold;
margin-top:0.5em;padding:5px;text-decoration:underline;",
paste("Last Year:", lastYr_date)))
})
# Render reactive HTML - map titles
output$title_row_lastYr <- renderUI({
if (input$lastYr_checkbox == 1) {
title_row_lastYr()
}
})
#### * Error messages ####
# Report error message if "submit" button is hit before typing an address
address_error <- eventReactive(input$address_submit, {
validate(
need(input$address != "", "Please enter an address or location")
)
})
output$address_error <- renderUI({ # Send output to UI
address_error()
})
# Report error message if coordinates cannot be obtained for an address
coords <- eventReactive(input$address_submit, {
if (input$address != "") {
tribble(~addr, input$address) %>%
geocode(addr)
}
})
# NA values will be in coordinates output if address couldn't be geocoded
output$coords_error <- renderText({
if (any(is.na(coords()))) # If any NA values, return message
return("<font color=\"#7F7F7F\">Sorry, this address could not
be geocoded! Check for typos.</font>")
})
# Generate leaflet maps ----
# Different maps are rendered depending on radioButton inputs
observeEvent(input$risk, {
# Rasters to map
raster_current <- switch(input$risk,
"Three Day" = rasts_current[[2]],
"Four Day" = rasts_current[[3]],
"Cumulative (Total)" = rasts_current[[1]])
#raster_current <- raster(raster_current)
# Raster to map
raster_lastYr <- switch(input$risk,
"Three Day" = rasts_lastYr[[2]],
"Four Day" = rasts_lastYr[[3]],
"Cumulative (Total)" = rasts_lastYr[[1]])
#raster_lastYr <- raster(raster_lastYr)
#### * Map legend and color palette ####
# Legend title
lgd_title <- switch(input$risk,
"Cumulative (Total)" = c("Total Risk"),
"Three Day" = c("3 Day</br>Risk"),
"Four Day" = c("4 Day</br>Risk"))
# Color palettes
# Long-term risk (total for year) uses a continuous scale
# Using same scale for both maps requires using scales for the
# raster with the highest risk value (i.e. greatest range of values)
both_rasters <- c(raster_current, raster_lastYr)
#max_rast <- stackApply(s, indices = rep(1, nlyr(s)), max) # highest
max_rast <- app(both_rasters, max)
# Long-term risk (total for year) uses different scale than short-term
pal_riskTotal <- colorNumeric(
palette = c("#01260c", "#009405", "#ffff00", "#da9101", "#c30010", "#4d0211"),
domain = values(max_rast), na.color = "transparent")
# Need to know number of unique values for color ramp
vals <- unique(values(max_rast))
#ncols <- length(vals[!is.na(vals)]) - 1
ncols <- length(vals[!is.na(vals)])
# Short-term risk uses a "green-yellow-red" color ramp to reflect that
# certain risk values are low vs. high.
# Pastel green-yellow-pink (matches site-based-model scale)
# Green-yellow-red
if (ncols < 10) {
#pal_risk <- colorRampPalette(c("#77dd76", "#bbf1c4", "#e0f6e3", "#fdfd96", "#ffefc0", "#f4d0d5", "#f4b5c7", "#f49ac2"))(10)
pal_risk <- colorRampPalette(c("#009405", "#ffff00", "#da9101", "#c30010"))(10)
pal_risk <- pal_risk[1:ncols]
} else {
pal_risk <- colorRampPalette(c("#009405", "#ffff00", "#da9101", "#c30010", "#4d0211"))(ncols)
}
# Viridis "inferno" palette
#pal_risk <- c("gray90", colorRampPalette(c("#0d0887","#cc4778","#f0f921"))(ncols))
# Define attributes for rasters so that legend shows values correctly
# TO DO: this is really annoying!!! Maybe there's an easier way but couldn't
# figure out a way to show rounded (integer only) values on color ramp
# Color palettes for current and last year
unique_vals_current <- sort(unique(values(raster_current))[!is.na(unique(values(raster_current)))])
unique_vals_lastYr <- sort(unique(values(raster_lastYr))[!is.na(unique(values(raster_lastYr)))])
pal_risk_current <- pal_risk[1:length(unique_vals_current)]
pal_risk_lastYr <- pal_risk[1:length(unique_vals_lastYr)]
# Define palette to use based on risk map selection
pal_current <- switch(input$risk,
"Cumulative (Total)" = pal_riskTotal,
"Three Day" = pal_risk_current,
"Four Day" = pal_risk_current,
)
pal_lastYr <- switch(input$risk,
"Cumulative (Total)" = pal_riskTotal,
"Three Day" = pal_risk_lastYr,
"Four Day" = pal_risk_lastYr,
)
# Render maps ----
output$risk_map <- renderUI({
# Using a height of 1000 and minZoom = 7 is another option but font too
# small and can't figure out an easy way to adjust font size.
#### * Current year map ####
map_current <- leaflet(height = 500, width = map_width(),
options = leafletOptions(
zoomControl = FALSE, minZoom = 6)) %>%
# Add OpenStreetMap layer
addProviderTiles(providers$CartoDB.Voyager) %>%
# Risk layer output
addRasterImage(raster_current, color = pal_current, opacity = 0.5,
group = "Risk value", layerId = "Risk value") %>%
# Risk layer raster query (use project = TRUE or get wrong values)
addImageQuery(raster(raster_current), project = TRUE, prefix = "", digits = 2,
layerId = "Risk value", position = "topleft",
type = "mousemove") %>%
# Add county lines / markers
addPolylines(data = state_sf, group = "States", opacity = 0.25,
color = "black", weight = 1.75) %>%
addPolylines(data = county_sf, group = "Counties", opacity = 0.15,
color = "black", weight = 1) %>%
###  Other leaflet map features
# Shows map coordinates as mouse is moved over map
addMouseCoordinates %>%
fitBounds(lng1 = -127, lat1 = 41.98, lng2 = -120.5, lat2 = 49.1664) %>%
# Change position of zoom control buttons
htmlwidgets::onRender("function(el, x) {
L.control.zoom({ position: 'topright' }).addTo(this)
}")
#### * Last year map ####
# Leaflet map for same date last year
map_lastYr <- leaflet(height = 500, width = map_width(),
options = leafletOptions(zoomControl = FALSE, minZoom = 6)) %>%
# Add OpenStreetMap layer
addProviderTiles(providers$CartoDB.Voyager) %>%
# Risk layer output
addRasterImage(raster_lastYr, color = pal_lastYr, opacity = 0.5,
group = "Risk value (last year)",
layerId = "Risk value (last year)") %>%
# Risk layer raster query (use project = TRUE or get wrong values)
addImageQuery(raster(raster_lastYr), project = TRUE, prefix = "", digits = 2,
layerId = "Risk value (last year)", position = "topleft",
type = "mousemove") %>%
# Add county lines / markers
addPolylines(data = state_sf, group = "States", opacity = 0.25,
color = "black", weight = 1.75) %>%
addPolylines(data = county_sf, group = "Counties", opacity = 0.15,
color = "black", weight = 1) %>%
###  Other map features
# Shows map coordinates as mouse is moved over map
addMouseCoordinates %>%
# Set bounds
fitBounds(lng1 = -127, lat1 = 41.98, lng2 = -120.5, lat2 = 49.1664) %>%
# Change position of zoom control buttons
htmlwidgets::onRender("function(el, x) {
L.control.zoom({ position: 'topright' }).addTo(this)
}")
#### * Final map add-ons ####
## Add legend
# Total risk
if (input$risk == "Cumulative (Total)") {
map_current <- map_current %>%
addLegend("bottomleft", title = lgd_title,
pal = pal_current, values = values(raster_current), opacity = 1)
map_lastYr <- map_lastYr %>%
addLegend("bottomleft", title = lgd_title,
pal = pal_lastYr, values = values(raster_lastYr), opacity = 1)
} else { # 3- and 4-day risk
map_current <- map_current %>%
addLegend("bottomleft", title = lgd_title, colors = pal_current, opacity = 1,
labels = sprintf("%.1f", unique_vals_current))
map_lastYr <- map_lastYr %>%
addLegend("bottomleft", title = lgd_title, colors = pal_lastYr, opacity = 1,
labels = sprintf("%.1f", unique_vals_lastYr))
}
# Return a synced "current date" and "last year same date" map
# if desired, otherwise just return map for current date
if (input$lastYr_checkbox == 1) {
out_map <- sync(map_current, map_lastYr, sync.cursor = FALSE)
} else {
out_map <- map_current
}
})
# Updates maps each time a new location is submitted!
observeEvent(input$address_submit, {
output$risk_map <- renderUI({
# Using a height of 1000 and minZoom = 7 is another option but font too
# small and can't figure out an easy way to adjust font size.
#### * Current year map ####
map_current <- leaflet(height = 500, width = map_width(),
options = leafletOptions(
zoomControl = FALSE, minZoom = 6)) %>%
# Add OpenStreetMap layer
addProviderTiles(providers$CartoDB.Voyager) %>%
# Risk layer output
addRasterImage(raster_current, color = pal_current, opacity = 0.5,
group = "Risk value",layerId = "Risk value") %>%
# Risk layer raster query (use project = TRUE or get wrong values)
addImageQuery(raster(raster_current), project = TRUE, prefix = "", digits = 2,
layerId = "Risk value", position = "topleft",
type = "mousemove") %>%
# Add county lines / markers
addPolylines(data = state_sf, group = "States", opacity = 0.25,
color = "black", weight = 1.75) %>%
addPolylines(data = county_sf, group = "Counties", opacity = 0.15,
color = "black", weight = 1) %>%
###  Other leaflet map features
# Shows map coordinates as mouse is moved over map
addMouseCoordinates %>%
fitBounds(lng1 = -127, lat1 = 41.98, lng2 = -120.5, lat2 = 49.1664) %>%
# Change position of zoom control buttons
htmlwidgets::onRender("function(el, x) {
L.control.zoom({ position: 'topright' }).addTo(this)
}")
#### * Last year map ####
# Leaflet map for same date last year
map_lastYr <- leaflet(height = 500, width = map_width(),
options = leafletOptions(zoomControl = FALSE, minZoom = 6)) %>%
# Add OpenStreetMap layer
addProviderTiles(providers$CartoDB.Voyager) %>%
# Risk layer output
addRasterImage(raster_lastYr, color = pal_lastYr,opacity = 0.5,
group = "Risk value (last year)",
layerId = "Risk value (last year)") %>%
# Risk layer raster query (use project = TRUE or get wrong values)
addImageQuery(raster(raster_lastYr), project = TRUE, prefix = "", digits = 2,
layerId = "Risk value (last year)",
position = "topleft", type = "mousemove") %>%
# Add county lines / markers
addPolylines(data = state_sf, group = "States", opacity = 0.25,
color = "black", weight = 1.75) %>%
addPolylines(data = county_sf, group = "Counties", opacity = 0.15,
color = "black", weight = 1) %>%
###  Other map features
# Shows map coordinates as mouse is moved over map
addMouseCoordinates %>%
# Set bounds
fitBounds(lng1 = -127, lat1 = 41.98, lng2 = -120.5, lat2 = 49.1664) %>%
# Change position of zoom control buttons
htmlwidgets::onRender("function(el, x) {
L.control.zoom({ position: 'topright' }).addTo(this)
}")
#### * Final map add-ons ####
## Add legend
# Total risk
if (input$risk == "Cumulative (Total)") {
map_current <- map_current %>%
addLegend("bottomleft", title = lgd_title,
pal = pal_current, values = values(raster_current), opacity = 1)
map_lastYr <- map_lastYr %>%
addLegend("bottomleft", title = lgd_title,
pal = pal_lastYr, values = values(raster_lastYr), opacity = 1)
} else { # 3- and 4-day risk
map_current <- map_current %>%
addLegend("bottomleft", title = lgd_title, colors = pal_current, opacity = 1,
labels = sprintf("%.1f", unique_vals_current))
map_lastYr <- map_lastYr %>%
addLegend("bottomleft", title = lgd_title, colors = pal_lastYr, opacity = 1,
labels = sprintf("%.1f", unique_vals_lastYr))
}
# Add circle markers for geocoded location if coordinates are not NA
output$coords_value_current <- renderText({
if (input$address != "") {
xy <- data.frame(x = coords()$long, y = coords()$lat)
rast_val <- terra::extract(raster_current, xy)[1,2]
if (!is.na(rast_val)) {
paste("<b>", input$risk, "Risk at Location:</b>", rast_val)
} else {
"<b>No risk forecast for this location - please try again<b>"
}
}
})
# Last year risk map
output$coords_value_lastYr <- renderText({
if(input$address != "" & input$lastYr_checkbox == 1) {
xy <- data.frame(x = coords()$long, y = coords()$lat)
rast_val <- terra::extract(raster_lastYr, xy)[1,2]
if (!is.na(rast_val)) {
paste("<b>", input$risk, "Risk at Location:</b>", rast_val)
} else {
"<b>No risk forecast for this location - please try again<b>"
}
}
})
#### * Final map output ####
# If input address doesn't return NULL coordinates, add markers and zoom
if (!(is.na(coords()$lat)) & !(is.na(coords()$long))) {
# Current year
map_current <- map_current %>%
addCircleMarkers(lat = coords()$lat, lng = coords()$long,
opacity = 0.75, color = "cyan",
weight = 3, fill = FALSE) %>%
setView(lng = coords()$long, lat = coords()$lat, zoom = 11)
# Last year
map_lastYr <- map_lastYr %>%
addCircleMarkers(lat = coords()$lat, lng = coords()$long,
opacity = 0.75, color = "cyan",
weight = 3, fill = FALSE) %>%
setView(lng = coords()$long, lat = coords()$lat, zoom = 11)
}
# Return a synced "current date" and "last year same date" map
# if desired, otherwise just return map for current date
if (input$lastYr_checkbox == 1) {
out_map <- sync(map_current, map_lastYr, sync.cursor = FALSE)
} else {
out_map <- map_current
}
})
})
})
}
# Run app ----
shinyApp(ui = ui, server = server)
rsconnect::deployApp("C:/Users/barkebri/Documents/Species/BOXB/Web_app/BOXB-webapp/)
rsconnect::deployApp("C:/Users/barkebri/Documents/Species/BOXB/Web_app/BOXB-webapp/")
setwd("C:/Users/barkebri/Documents/Species/BOXB/Web_app/BOXB-webapp/")
deployApp()
library(rsconnect)
deployApp()
deployApp()
